import React, { useState } from 'react'
import { Upload, AlertCircle, CheckCircle } from 'lucide-react'

function XmlUploader({ onXmlLoaded }) {
  const [dragActive, setDragActive] = useState(false)
  const [uploadStatus, setUploadStatus] = useState(null) // 'success', 'error', null
  const [errorMessage, setErrorMessage] = useState('')

  const validateXml = (xmlContent) => {
    // Verificar se contém nossa assinatura
    const hasSignature = xmlContent.includes('<!-- Generated by CreateMacros - GrandMA2 Macro Generator by Luan -->')
    
    if (!hasSignature) {
      return {
        isValid: false,
        message: 'Este arquivo não foi gerado pelo CreateMacros. Apenas arquivos gerados pelo sistema podem ser editados.'
      }
    }

    // Verificar se é um XML válido do GrandMA2
    if (!xmlContent.includes('<MA') || !xmlContent.includes('<Macro')) {
      return {
        isValid: false,
        message: 'Arquivo XML inválido. Certifique-se de que é um arquivo de macro do GrandMA2.'
      }
    }

    return {
      isValid: true,
      message: 'Arquivo carregado com sucesso!'
    }
  }

  const parseXmlToStructure = (xmlContent) => {
    try {
      // Extrair as linhas da macro do XML
      const macroLines = []
      const lines = xmlContent.split('\n')
      
      for (const line of lines) {
        if (line.includes('<text>') && line.includes('</text>')) {
          const textMatch = line.match(/<text>(.*?)<\/text>/)
          if (textMatch) {
            macroLines.push(textMatch[1])
          }
        }
      }

      // Reconstruir a estrutura de grupos e efeitos
      const groups = []
      let currentGroup = null
      let currentEffect = null
      let groupId = 1
      let effectId = 1

      for (const line of macroLines) {
        
        if (line === 'Clear' && currentGroup) {
          // Finalizar grupo atual
          if (currentGroup) {
            groups.push(currentGroup)
            currentGroup = null
          }
        } else if (line.startsWith('Group ')) {
          // Novo grupo
          if (currentGroup) {
            groups.push(currentGroup)
          }
          
          const groupValue = line.replace('Group ', '').replace(/"/g, '')
          currentGroup = {
            id: groupId++,
            groupValue: groupValue,
            effects: []
          }
        } else if (line.startsWith('Store Effect ')) {
          // Novo efeito
          if (!currentGroup) {
            // Se não há grupo, criar um padrão
            currentGroup = {
              id: groupId++,
              groupValue: '1',
              effects: []
            }
          }

          // Padrão para capturar Store Effect X.Y.* /o, Store Effect X.* /o, ou Store Effect X.Y /o
          const effectMatch = line.match(/Store Effect (\d+)(?:\.(\d+))?(?:\.\*)? \/o/)
          
          if (effectMatch) {
            const effectNumber = parseInt(effectMatch[1])
            const lineNumber = effectMatch[2] ? parseInt(effectMatch[2]) : null
            
            // Verificar se já existe um efeito com este número
            let existingEffect = currentGroup.effects.find(e => e.effectNumber === effectNumber)
            
            if (!existingEffect) {
              // Criar novo efeito
              existingEffect = {
                id: effectId++,
                effectNumber: effectNumber,
                isComplex: false,
                effectLines: []
              }
              currentGroup.effects.push(existingEffect)
            }
            
            // Se tem lineNumber, é um efeito complexo
            if (lineNumber) {
              existingEffect.isComplex = true
              if (!existingEffect.effectLines.find(l => l.lineNumber === lineNumber)) {
                existingEffect.effectLines.push({
                  id: effectId++,
                  lineNumber: lineNumber
                })
              }
            }
          }
        }
      }

      // Adicionar o último grupo se existir
      if (currentGroup) {
        groups.push(currentGroup)
      }

      // Se não há grupos, criar um grupo padrão
      if (groups.length === 0) {
        groups.push({
          id: 1,
          groupValue: '1',
          effects: [{
            id: 1,
            effectNumber: 1,
            isComplex: false,
            effectLines: []
          }]
        })
      }

      return {
        macroText: macroLines.join('\n'),
        groups: groups
      }
    } catch (error) {
      console.error('Erro ao processar XML:', error)
      return null
    }
  }

  const handleFile = (file) => {
    const reader = new FileReader()
    
    reader.onload = (e) => {
      const xmlContent = e.target.result
      const validation = validateXml(xmlContent)
      
      if (validation.isValid) {
        const parsedData = parseXmlToStructure(xmlContent)
        if (parsedData) {
          setUploadStatus('success')
          setErrorMessage('')
          onXmlLoaded(parsedData)
        } else {
          setUploadStatus('error')
          setErrorMessage('Erro ao processar o conteúdo do XML.')
        }
      } else {
        setUploadStatus('error')
        setErrorMessage(validation.message)
      }
    }
    
    reader.readAsText(file)
  }

  const handleDrag = (e) => {
    e.preventDefault()
    e.stopPropagation()
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true)
    } else if (e.type === 'dragleave') {
      setDragActive(false)
    }
  }

  const handleDrop = (e) => {
    e.preventDefault()
    e.stopPropagation()
    setDragActive(false)
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleFile(e.dataTransfer.files[0])
    }
  }

  const handleChange = (e) => {
    e.preventDefault()
    if (e.target.files && e.target.files[0]) {
      handleFile(e.target.files[0])
    }
  }



  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2 mb-4">
        <Upload className="w-5 h-5 text-primary-600" />
        <h3 className="text-lg font-medium text-gray-900">Carregar XML Existente</h3>
      </div>

      <div
        className={`relative border-2 border-dashed rounded-lg p-6 text-center transition-colors ${
          dragActive 
            ? 'border-primary-500 bg-primary-50' 
            : uploadStatus === 'success'
            ? 'border-green-500 bg-green-50'
            : uploadStatus === 'error'
            ? 'border-red-500 bg-red-50'
            : 'border-gray-300 bg-gray-50'
        }`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
      >
        <input
          id="file-upload"
          name="xml-file"
          type="file"
          accept=".xml"
          onChange={handleChange}
          className="hidden"
        />
        
        <div className="space-y-4">
          {uploadStatus === 'success' ? (
            <div className="flex items-center justify-center gap-2 text-green-600">
              <CheckCircle className="w-6 h-6" />
              <span className="font-medium">Arquivo carregado com sucesso!</span>
            </div>
          ) : (
            <>
              <Upload className="w-12 h-12 mx-auto text-gray-400" />
              <div>
                <p className="text-sm text-gray-600">
                  Arraste e solte um arquivo XML aqui, ou{' '}
                  <label
                    htmlFor="file-upload"
                    className="text-primary-600 hover:text-primary-700 font-medium cursor-pointer"
                  >
                    clique para selecionar
                  </label>
                </p>
                <p className="text-xs text-gray-500 mt-1">
                  Apenas arquivos XML gerados pelo CreateMacros são aceitos
                </p>
              </div>
            </>
          )}
        </div>

        {uploadStatus === 'error' && (
          <div className="mt-4 p-3 bg-red-100 border border-red-200 rounded-lg">
            <div className="flex items-center justify-between">
              <p className="text-sm text-red-700">{errorMessage}</p>
              <button
                onClick={() => {
                  setUploadStatus(null)
                  setErrorMessage('')
                }}
                className="text-xs text-red-600 hover:text-red-700 font-medium"
              >
                Tentar novamente
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export default XmlUploader 